# -*- coding: utf-8 -*-
"""
Created on Sun Jun 10 20:15:59 2018
uh_forward solution preparation 

@author: Berdakh
"""
import os
import os.path as op
import mne
import numpy as np  # noqa
from mayavi import mlab  # noqa
from surfer import Brain  # noqa

#%% GLOBAL VARIABLES 
subjectName = 'S9014'
subjectDir = 'C:\\uhdata\\data\\MRI_Files'

#%% STEP 1: COMPUTER THE SOURCE SPACE (SOURCE GRID ON MRI)
"""
Compute Source Space
The source space defines the position of the candidate source locations. 
The following code compute such a cortical source space with an OCT-5 resolution.
"""
src = mne.setup_source_space(subjectName, spacing='oct5',subjects_dir=subjectDir) 

filename2save = "".join([subjectName,'-src.fif'])
info = mne.write_source_spaces(filename2save,src, overwrite=True)

#%% Visualize the source space 
pwd = os.getcwd()
srcfname = op.join(pwd, filename2save)

patch_stats = True  # include high resolution source space
src1 = mne.read_source_spaces(srcfname, patch_stats=patch_stats)
src1.plot(head=True,brain=True,skull=True,subjects_dir = subjectDir)
#%% Read and visualize the BEM model meshes generated by FreeSurfer 
mne.viz.plot_bem(subject=subjectName, subjects_dir=subjectDir,
                 brain_surfaces='white',orientation='coronal')
#surface = mne.read_surface('inner_skull.surf')
# visualize the source space using mayavi 

brain = Brain(subjectName, 'lh', 'inflated', subjects_dir=subjectDir)
surf = brain.geo['lh']

vertidx = np.where(src[0]['inuse'])[0]

mlab.points3d(surf.x[vertidx], surf.y[vertidx],
              surf.z[vertidx], color=(1, 1, 0), scale_factor=1.5)

#%% STEP 2: COMPUTER THE FORWARD SOLUTION
"""
The BEM solution requires a BEM model which describes the geometry 
of the head the conductivities of the different tissues.

NOTE that the BEM does not involve any use of the trans file. 
The BEM only depends on the head geometry and conductivities. 
It is therefore independent from the MEG data and the head position.

The forward operator, commonly referred to as the gain or leadfield matrix
requires the co-registration later on. 
"""
conductivity = (0.3, 0.006, 0.3)  # for three layers

model = mne.make_bem_model(subjectName, 
                           subjects_dir=subjectDir, 
                           conductivity=conductivity,
                           verbose=None)
# save 
bem2save = "".join([subjectName,'-bem.fif'])
mne.write_bem_surfaces(bem2save, model)  

bem_sol = mne.make_bem_solution(model)
# save bem solution 
bem2solution = "".join([subjectName,'-bemsol.fif'])
mne.write_bem_solution(bem2solution, bem_sol)

#%% STEP 3: CO-REGISTRATION STEP (MANUAL STEP)
mne.gui.coregistration()
# at this stage you need to use GUI.

#%% MAKE FORWARD SOLUTION
pwd = os.getcwd()
raw_fname = op.join(pwd, 'S9007_ses1_cond1_block0002-epo.fif')
trans = op.join(pwd, 'S9014-trans.fif') 
info = mne.io.read_info(raw_fname)

# Here we look at the dense head, which isn't used for BEM computations but
# is useful for coregistration.
mne.viz.plot_alignment(info, trans=trans, subject=subjectName, subjects_dir=subjectDir, 
                       surfaces='head', coord_frame='head', meg=None, eeg='original', 
                       dig=False, ecog=False, src=None, mri_fiducials=False, bem=None, 
                       seeg=False,show_axes=False, fig=None, 
                       interaction='trackball', verbose=None)
#%% will take a few mintues
fwd = mne.make_forward_solution(raw_fname, trans=trans, src=src, bem=bem_sol,
                                meg=False, eeg=True, mindist=5.0)
print(fwd)
#%% We can explore the content of fwd to access the numpy array that contains the gain matrix.
leadfield = fwd['sol']['data']
print("Leadfield size : %d sensors x %d dipoles" % leadfield.shape)
"""
To extract the numpy array containing the forward operator corresponding 
to the source space fwd[‘src’] with cortical orientation constraint 
we can use the following:
"""
fwd_fixed = mne.convert_forward_solution(fwd, surf_ori=True, force_fixed=True,
                                         use_cps=True)
leadfield = fwd_fixed['sol']['data']
print("Leadfield size : %d sensors x %d dipoles" % leadfield.shape)

#%% 
fwdname = "".join([subjectName,'-fwd.fif'])
mne.write_forward_solution(fwdname, fwd, overwrite=False, verbose=None)
"""
To save to disk a forward solution you can use mne.write_forward_solution() 
and to read it back from disk mne.read_forward_solution(). 
Don’t forget that FIF files containing forward solution should end with -fwd.fif.

To get a fixed-orientation forward solution, use mne.convert_forward_solution() 
to convert the free-orientation solution to (surface-oriented) fixed orientation.
"""
#%% VISUALIZE THE MRI OF THE SUBJECT 
#import nilearn

import matplotlib.pyplot as plt
from nilearn.plotting import plot_anat

t1_fname = op.join(subjectDir,subjectName,'mri/T1.mgz')
# Plotting with nilearn ######################################################
plot_anat(t1_fname), plt.show()
